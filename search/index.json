[{"content":"Java八股文面试题 一、redis篇 1.redis使用场景-缓存-缓存穿透 缓存击穿：查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库\n解决方案一：缓存空数据，查询返回数据的数据为空，但仍然把这个空结果进行缓存\n优点：简单\n缺点：消耗内存，可能发生数据不一致的问题\n解决方案二：布隆过滤器\n优点：内存占有较少，没有多余key\n缺点：实现复杂，存在误判\n布隆过滤器\nbitmap(位图)：相当于是一个以（bit）位为单位的数组，数组中每个单位智能粗出二进制数0或1\n布隆过滤器作用：布隆过滤器可以用于检索一个元素是否存在一个集合中\n存储数据：id为1 的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置改为1\n查询数据：使用相同hash函数获取hash值，判断对应位置是否都为1\n使用布隆过滤器的两种场景：\n初始使用：注册用户是就想容器中新增数据，就不需要任务向容器中存数据了\n使用过程中引用：读取数据源将目标数据刷到布隆过滤器\n2.缓存击穿 缓存击穿：给某个key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能瞬间把DB压垮\n解决方案一：互斥锁：强一致，性能差\n方案二：逻辑过期：高可用，性能优，但不能保证数据绝对一致性\n3. 问：redis作为缓存，mysql数据如何与redis数据同步呢（双写一致性问题） 答：一定需结合自己的业务背景（一致性要求高、允许延迟一致）\n双写一致性：当修改了数据库的数据也要同步更新缓存中的数据，缓存和数据库的数据要保持一致\n​\t1读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间\n​\t2.写操作：延迟双删 ：先删缓存还是先删数据库？ 为什么要删除两次缓存？ 为什么要延迟删除？\n确保数据的强一致性：读多写少：共享锁：读锁readLock，加锁之后，其他线程可以共享读操作\n​\t排他锁：独占锁writeLock，加锁后，阻塞其他线程读写操作\n性能较低\n异步通知保证数据的最终一致性：\n基于mq\n基于canal的异步通知：\n4.问redis作为缓存，数据持久化是怎么做的？ ​\tredis中提供了两种数据持久化的方式：1、RDB 2、AOF\n4.1\tRDB全称Redis Database Backup file （redis）数据备份文件，也叫做redis数据快照，简单来说就是把内存中的所有数据都记录到磁盘中。当redis实例故障重启后，从磁盘读取快照文件，恢复数据。\n4.1.1 主动备份：\n​\tredis内部有触发rdb的机制，可在redis.config文件下找到，格式如下：\nRDB的执行原理\nbgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。\nfork采用的时copy-on-write技术：1.当主进程执行读操作时，访问共享内存； 2.当主进程执行写操作时，则会拷贝一份数据，执行写操作\n4.2 AOF：全称Aooend Only File（追加文件）。redis处理每一个写命令都会记录在AOF文件，可以看作时命令日志文件。\nAOF默认关闭，需要修改redis.conf配置文件来开启AOF：\nAOF的命令记录的频率也可以通过redis.conf配置\n因为是记录命令AOF文件会比RDB文件大得多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。用过执行bgrewriteof命令，可以让AOF文件执行重写功能，用最少的命令达到相同的效果\nRDB与AOF对比：\nRDB AOF 持久化方式 定时对整个内存做快照 记录每一次执行的命令 数据完整性 不完整，两次备份之间会丢失 相对完整，取决于刷盘策略 文件大小 会有压缩，文件体积小 记录命令，文件体积很大 宕机恢复速度 很快 慢 数据恢复优先级 低，因为数据完整性不如AOF 高，因为数据完整性更高 系统资源占用 高，大量CPU和内存消耗 低，主要是磁盘Io资源，但AOF重写时会占用大量CPU和内存资源 使用场景 可以容忍数分钟的数据丢失，追求更快的启动速度 对数据安全性要求较高常见 5.假如redis的key过期后会立即删除么？ Redis对数据设置数据的有效时间，数据过期以后，就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略（数据过期策略）\nredis数据删除策略：\n惰性删除：设置该key过期时间后，我们不去管他，当需要该key时，我们在检查其是否过期，如果过期，我们删除掉它，反之返回该key\n优点：对cpu友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查\n缺点：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放\n定期删除：每隔一段时间，我们就对一些key进行检查，删除里面过期的key（从一定数量的数据库中去除一定数量的随机key进行检查。并删除其中过期的key）。\n定期删除有两种模式： 1.SLOW模式是定时任务，执行频率默认10hz，每次不超过25ms，通过修改配置文件redis.conf的hz选项来调整次数\n2.FAST模式执行频率不固定，但每次间隔 不低于2ms，每次耗时不超过1ms\n优点：可以通过限制删除操作执行的时长和频率来减少删除操作对cpu的影响，另外定期删除也能有效释放过期键占用的内存\n缺点：难以确定删除操作执行的时长和频率。\nRedis的过期删除策略：惰性删除+定期删除两种策略进行配合使用\n6.如果缓存过多，内存是有限的，内存被占满了怎么办？ 其实就是想问redis的数据淘汰策略是什么？ 数据淘汰策略：当redis中的内存不够用时，此时在向redis中添加新的key，那么redis就会按照莫一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。\nredis支持八种不同策略来选择要删除的key：\n关于数据淘汰策略其他面试题目 1.数据库中有1000万数据，redis中智能缓存20w数据，如何保证reids中的数据都是热点数据？\n使用allkeys-lru（挑选最近最少使用的数据淘汰策略）淘汰策略，留下的都是经常访问的热点数据\n2.redis的内存用完了会发生什么\n主要看数据淘汰策略是什么？如果时默认配置，会直接报错\n7.redis集群有哪些方案？ 三种：主从复制、哨兵模式、分片集群\n主从复制： 单节点redis的并发能力是有上线的，要进一步提高redis并发能力，就需要搭建主从集群，实现读写分离\n主从同步原理：\n主从全量同步：\n主从增量同步：（slave重启或者后期数据变化）\n问介绍一下redis的主从同步：\n单节点redis的并发能力是有上限的，要进一步提高rerdis的并发能力，就需要搭配主从集群，实现读写分离一般都是一主多从，主节点负责写数据，从节点负责读数据\n主从同步流程： 全量同步\n1.从节点请求主节点同步数据（replication id、offset）\n2.主节点判断是否是第一次请求，是第一次就与从节点同步版本信息（replication id和offset）\n3。主节点执行bgsave生成rdb文件后，发送给从节点去执行\n4.在rdb生成期间，主节点会以命令的方式记录到缓存区（一个日志文件）\n5.把生成后的命令日志文件发送给节点进行同步\n增量同步：\n1.从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取节点的offset值\n2.主节点命令日志中获取offset值之后的数据，发送给节点进行数据同步\n8.redis可重入锁原理 流程图：\n获取锁的lua脚本：\n释放锁的lua脚本：\nredisson锁重试和看门狗机制：\n9.redis哨兵模式和集群脑裂 redis提供了哨兵（sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：\n监控：sentinel会不断检查您的master和slave是否按预期工作\n自动故障恢复：如果master故障，sentinel会将一个slave提升未master。当故障实例恢复后也以新的master为主\n通知：sentinel充当redis客服段的服务发现来源，当集群发生故障转移时，会将最新的信息推送给redis的客户端\n哨兵选主规则\n首先判断主从节点断开时间长短，如超过指定值就排该从节点\n然后判断从节点的slave-priority值，越小优先级越高\n如果slave-prority一样，则判断slave节点的offset值，越大优先级越高\n最后是判断slave节点的运行id大小，越小优先级越高\n问：怎么保证redis的高并发可用\n哨兵模式：实现主从集群的自动故障恢复（监控，自动故障恢复，通知）\n你们使用redis是单点还是集群，哪种集群\n主从（一主一从）+哨兵就可以了。单节点不超过10g内存，如果reids内从不足则可以给不同服务分配独立的redis主从节点\nredis集群脑裂，该怎么解决\n集群脑裂是由于主节点和从节点和sentinel处于不同的网络分区，导致sentinel没有能够感知到主节点心跳，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的节点哪里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将老的主节点降为从节点，这是再从新master同步数据，就会导致数据丢失\n解决：我们可以修改redis的配置，可以设置最小的从节点数量以及缩短主从数据同步的延迟时间，达不到要求的就拒绝请求，就可以避免大量的数据丢失\n10.分片集群，数据读写规则 redis的分片集群有什么作用：\n集群中有多个master，每个master保存不同数据\n每个master都可以用多个slave节点\nmaster之间互相ping检测彼此健康状态\n客户端请求可以访问集群任意节点，最终都会被转发到正确节点\nredis分片集群中数据是怎么存储和读取的？\nredis分片集群引入了哈希槽的概念，redis集群中有16384个哈希槽\n将16384个插槽分配到不同的实例\n读写数据：根据key的有效部分计算哈希值，对16384取余（有小部分：如果key前面有大括号，大括号中的内容就是有效部分，如果没有，则以key本身作为有效部分）余数作为插槽，寻找插槽所在的实例\n11.Redis是单线程的，但是为什么还那么快 redis是纯内存操作，执行速度非常快\n采用单线程，避免不需要的上下文切换可竞争条件，多线程还要考虑线程安全问题\n使用I/O多路复用模型，非阻塞IO\n二、常见集合篇 1.ArrList-数据结构-数组： 数组：是一种用连续的内存空间存储相同数据类型数据的线性数据结构\n寻址公式：a[i] = baseAddress + i*dataTypeSize\nbaseAddress:数组的首地址\ndataTypeSize：代表数组中元素类型的大小，int型的数据，dataTypeSize=4个字节\n为什么数组索引从0开始呢？\n在根据数组索引获取元素时，会用索引和寻址公式来计算内存所对应的元素数据，寻址公式是：数组的首地址+索引*存储数据的类型大小\n如果数组的索引从1开始，寻址公式中，就需要增加一次减法操作，对于cpu来说就多了一次指令，性能不高\n插入和删除时间复杂度：\n插入和删除时，为保证数据的内存连续性，需要挪动数组元素，平均时间复杂度为O(n)\n2.ArrayList底层的实现原理是什么？ 1.ArrayList底层是动态数组实现的\n2.ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10\n3.ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组\n4.ArrayList在添加数据的时候：\n​\t确保数组已使用长度（size）加1之后足够存下下一个数据\n​\t计算数组的容量，如果当前数组已使用长度+1后的大于当前数组长度，则调用grow方法扩容（原来的1.5倍）\n​\t确保新增的数据有地方存储后，则将新元素添加到位于size的位置上\n​\t返回添加成果布尔值\n3.如何实现数组和List之间的转换 数组转List，使用JDK中java.util.Arrats工具类的asList方法\nList转数组，使用List的toArray方法。无参toArray方法返回Object数组，传入初始化长度的数组对象，返回该数组对象\nArrays.asList转List后，如果修改了数组内容，list受影响吗\nList用toArray转数组后，如果修改了List内容，数组受影响吗\n答：\nArrays.asList转换list之后，如果修改了数组内容，list受影响，因为它的底层使用的arrays类中的一个内部类ArrayList来构建的集合，这个集合的构造器中，把我们传入的这个集合进行包装而已，最终都是指向同一个内存地址\nlist使用了toArray转数组后，如果修改了list内容，数组不受影响，当调用了toarray之后，在底层是他进行了数组的拷贝，跟原来的元素就没什么关系了，所以即使修改了list之后，数组不受影响\n4.ArrayList和LinkedList的区别是什么？ 1：底层数据结构\narrayList是动态数组的数据结构实现\nlinkedList是双向链表的数据结构实现\n2：操作数据效率\narrayList按照下标查询的时间复杂度O（1）[内存是连续的，根据寻址公式],Linked\nList不支持下标查询\n查找（未知索引）：ArrayLIst需要遍历，链表也需要遍历，时间复杂度都是O（n）\n新增和删除：\n3.内存空间占用\narrayList底层是数组，内存连续，节省内存\nLinkedList是双向链表需要存储数据，和两个指针，更占内存\n4.线程安全\nArrayList和LinkedList都不是线程安全的\n如果需要保证线程安全，有两种方案\n​\t在方法内使用，局部变量则是线程安全的\n​\t使用线程安全的ArrayList和LinedList\n1 2 List\u0026lt;Object\u0026gt; syncArrayList = Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Object\u0026gt; syncLinkedList = Collections.synchronizedList(new LinkedList\u0026lt;\u0026gt;()): ​\n5.数据结构-散列表 1.什么是散列表？\n散列表（hash table）又名哈希表/Hash表\n根据键（key）直接访问在内存存储位置值（value）的数据结构\n由数组演化而来，利用了数组支持按照小标进行随机访问数据\n2.散列冲突\n散列冲突又称哈希冲突，哈希碰撞\n指多个key映射到同一个数组下标位置\n3.散列冲突-链表发（拉链）\n数组的每个下标位置称之为桶（bucket）或者槽（slot）\n每个桶会对应一条链表\nhash冲突后的元素都会放到相同槽位对应的链表或红黑树中\n6.HashMap实现原理 HashMap的数据结构：底层使用hash表数据结构，即数组和链表或红黑树\n1.当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标\n2.存储时，如果出现hash值相同的key，此时有两种情况。\n​\t如果key相同则覆盖原始值、\n​\t如果key不同（出现冲突），则将当前的key-value放入链表（链表长度\u0026gt;=8且数组长度\u0026gt;=64转为红黑树）或红黑树中\n3.获取时，直接查找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值\n7.HashMap中put方法的具体实现 1.判断键值对数组table是否为空或为null，否则执行resize0进行扩容（初始化) 2.根据键值key计算hash值得到数组索引 3.判断table[i]==null，条件成立，直接新建节点添加\n4.如果table[i]==null,不成立 4.1判断table[ij]的首个元素是否和key一样，如果相同直接覆盖value 4.2判断table[i]是否为treeNode，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对 4.3遍历table[]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入 操作，遍历过程中若发现key已经存在直接覆盖value 5.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。\n8.HashMap中的扩容机制： 1.在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次扩容都是达到了扩容阈值（数组长度*0.75）\n2.每次扩容的时候，都是扩容之前容量的2倍\n3.扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中\n​\t没有hash冲突的节点，则直接用e.hash \u0026amp; (newCap - 1)计算新数组的索引位置\n​\t如果是红黑树，走红黑树的添加\n​\t如果是链表，则可能需要拆分链表，判断(e.hash \u0026amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上\n9 .hashMap的寻址算法 1.计算对象的hashCode()\n2.在调用hash()方法进行二次哈希，hashCode值右移16位再异或运算，让哈希分布更为均匀\n3.最后（capacity-1）\u0026amp;hash得到索引\n10.为何HashMap的数组长度一定是2的次幂 1.计算索引时效率更高：如果是2的n次幂可以使用位与运算代替取模\n2.扩容时重新计算索引效率更高：hash\u0026amp;oldCap==0的元素留在原来位置，否则新位置=旧位置+oldCap\n11.jdk1.7中hashmap死循环问题 A: 再jdk1.7中的hashmap中再数组进行扩容的时候，因为链表时头插法，再进行数据迁移的过程中，有可能导致死循环\n比如说：现在有两个线程\n线程一：读取到了当前的hashmap数据，数据中一个链表再准备扩容时，线程二介入\n线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。\n线程一：继续执行的时候就会出现死循环问题。\n线程一先将A移入新的链表，再将B插入到链头，由于另一个线程的原因，B的next指向了A，所以B-\u0026gt;A-\u0026gt;B，形成循环。\n当然，JDK8将扩容算法做了调整，不在将元素加入链表头（而是保持与扩容前一样的顺序），尾插法，就避免了jdk7中死循环问题\n二.并发编程篇 1.创建线程的方式有哪些？ 1.继承Thread类\n2.实现runnable接口\n3.实现callable接口\n4.线程池创建线程\nrunnable和callable有什么区别 1.runnable接口run方法没有返回值\n2.Callable接口call方法有返回值，是个泛型，和Future，FutureTask配合可以用来获取异步执行结果\n3.Callable接口的call()方法允许抛出异常，而Runnable接口的run方法的异常只能在内部消化，不能继续上抛\nrun()和start()有什么区别？ 1.start():用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次\n2.run()：封装了要被线程执行的代码可以被调用多次\n2.线程包括哪些状态 新建（NEW），可运行（RUNNABLE），阻塞（BLOCKED），等待（WAITING），时间等待（TIMED_WALTING)，终止（TERMINATED）\n3.线程状态之间是如何变换的 4.在java中wait和sleep方法的不同 共同点：wait(),wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态\n不同点：\n1.方法归属不同\n​\tsleep(long)是Thread的静态方法\n​\t而wait(),wait(long)都是Object的成员方法，每个对象都有\n2.醒来时机不同\n​\t执行sleep(long)和wait(long)的线程都会在等待相应毫秒后醒来\n​\twait(long)和wait()还可以被notify唤醒，wait()如果不唤醒就一直等下去\n​\t他们都可以被打断唤醒\n3.锁特性不同\n​\twait方法的调用必须先获取wait对象的锁，而sleep则无此限制\n​\twait方法执行后会释放对象锁，允许其他对象获得该对象锁（我放弃cpu，但你们还可以用）\n​\t而sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃cpu，你们也用不了）\n5.如何停止一个正在运行的线程？ 有三种方式可以停止线程\n1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止\n2.使用stop方法强行终止（不推荐，方法已作废）\n3.使用interrupt方法中断线程\n​\t1.打断阻塞的线程（slepp，wait，join）的线程，线程会抛出InterruptedException异常\n​\t2.打断正常的线程，可以根据打断状态来标记是否退出线程。\n6.synchrinized关键字的底层原理 1.synchronized[对象锁]采用互斥的方法让同一时刻至多只有一个线程能持有[对象锁]\n2.他的底层由monitor实现的，monitor是jvm级别的对象（C++实现）\n3.在monitor内部有三个属性，分别是owner，entrylist，，waitset\n4.其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于waiting状态的线程\n7.Monitor实现的锁属于重量级锁，你了解过锁升级么？ 8.谈谈JMM（java内存模型） 1.JMM java内存模型，定义了共享内存中多线程程序读写操作的行为规范，通过这些规则来规范对内存的读写操作从而确保指令的正确性\n2.JMM把内存分位两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）\n3.线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存\n三数据库篇 1.Mysql中如何定位慢查询 ​\t当我们做压测时候有的接口非常的慢，接口相应时间超过了2s以上，因为我们当时的系统部署了运维的监控系统Skywalking，在展示的报表中可以看到是哪个接口比较慢，并且可以分析这个接口哪个部分比较慢，这里可以看到sql的具体执行时间\n​\t在mysql中也提供了慢日志查询的功能，可以在mysql的系统配置文件中开启这个慢日志的功能，并且也可以设置sql执行超过多少时间来记录到日志文件中，我们就可以在日志文件找到比较慢的sql\n2.sql语句执行很慢，如何分析？ ​\t如果一条sql执行很慢，我们通常会使用mysql自动的执行计划explain来去查看这条sql的执行情况，比如在这里米娜可以通过key和key_len检查是否命中索引，如果本身已经添加了索引，也可以判断索引是否有失效的情况，第二个，可以通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描，第三个可以通过extra建议来判断，是否出现了回表的情况，如果有，可以尝试添加索引或者修改返回字段来修复\n3.什么是索引？ ​\t他是帮助mysql高效获取数据的数据结构，主要是用来提高数据检索的效率，降低数据库的io成本，通过索引列对数据进行排序，降低数据排序的成本，也降低了cpu的消耗\n4.索引底层数据结构了解么？ ​\tmysql的默认存储引擎innoDB采用的B+树的数据结构来存储索引，选择B+树的主要原因是：第一阶树更多，路径更短，第二个磁盘读写代价B+树更低，非叶子节点只存储指针，叶子节点存储数据，第三B+树便于扫库和区间查询，叶子节点是一个双向链表\n5.B树和B+树区别是什么 第一：在B树中，非叶子节点和叶子节点都会存放数据，而B+树的所有数据都存储在叶子节点，在查询时，B+树查找效率更加稳定\n第二：在进行返回查询时，B+树效率更高，因为B+树都存在叶子节点存储，并且叶子节点是一个双向链表\n6.什么是聚簇索引什么是非聚簇索引 聚簇索引主要是指数据与索引放在一块，B+树的叶子节点保存了整行的数据，有且只有一个，一般情况下主键作为聚簇索引\n非聚簇索引指的是数据与索引分开存储，B+树的叶子节点保存对应的主键。可以有多个，一般我们自己定义的索引都是非聚簇索引\n7.什么是回表查询 回表的意思是通过二级索引找到对应的主键值，然后再通过主键值找到聚簇索引中所对应的整行数据，这个过程就是回表\n8.什么是覆盖索引 ​\t覆盖索引是指select查询语句使用了索引，再返回的列，必须在索引中全部能够找到，如果我们使用id查询，它会直接走聚簇索引查询，一次索引扫描，直接返回数据性能高\n​\t如果按照二级索引查询数据的时候，返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select*，尽量在返回的列中都包含添加索引的字段\n9.MySQL超大分页怎么处理 超大分页一般都是在数据量比较大时，我们使用了limit分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用覆盖索引和子查询来解决\n先分页查询数据的id字段，确定id之后，再用子查询来过滤，只查询这个id列表中的数据就可以了，因为查询id的时候，走的是覆盖索引，所以效率可以提升很多\n10.创建索引的原则？ 表中的数据要超过10w以上，我们才会创建索引，并且添加索引的字段是查询比较繁琐的字段，也就是像作为查询条件，排序字段或分组的字段这些\n通常创建索引的时候都是使用复合索引来创建，一条sql的返回值，尽量使用覆盖索引，入字段的区分度不高，我们也会把它放在组合索引后面的字段\n如果一个字段的内容较长，我们会考虑使用前缀索引来使用，当然并不是所有字段都需要添加索引，这个索引的数量也要控制，因为添加索引也会导致新增改的速度变慢\n11.什么情况下索引会失效 违反最左前缀法则\n范围查询右边的列，不能使用索引\n不要在索引列上进行运算操作，索引将失效\n字符串不加单引号，造成索引失效（类型转换）\n以%开头的Like模糊查询，索引失效\n12.sql优化经验 A:这几个方面考虑，比如建表的时候，使用索引，sql语句的编写，主从复制，读写分离，还有一个是如果量比较大的话，可以考虑分库分表\nQ:创建表的时候，如何优化\nA:这个主要参考阿里出的哪个开发手册《松山版》，比如，在定义字段的时候需要结合字段的内容来选择合适的类型，如果是数值的话，像tinyint，int，bigint这些类型，要根据实际情况选择，如果是字符串类型也是结合存储的内容来选择char和varchar或者text类型\nQ：在使用索引时如何优化？\nQ:对sql语句有哪些优化\nA:select语句务必声明字段名称，不要直接使用select *，还有就是要注意sql语句避免造成索引失效的写法；如果是聚合查询，尽量用union all代替union，union会多一次过滤，效率比较低；如果是表关联的话，尽量使用innerjoin，不要使用left join right join，如必须使用 一定要以小表驱动大表\n13.事务的特性是什么？ ACID，分别是指：原子性，一致性，隔离性，持久性：举个例子：A向B转账500，转账成功，A扣除500，B增加500，原子操作体现在要么都成功，要么都失败\n在转账过程中，数据要一致，A扣除了500，B必须增加500\n在转账过程中，隔离性体现在A向B转账，不能受其他事务干扰\n在转账过程中，持久性体现在事务提交后，要把数据持久化\n14.并发事务带来哪些问题？ 第一脏读，当一个事务正在访问数据并对数据进行了修改，而这种修改还没有提交到数据库中，这是另一个事务也访问了这个数据，因为这个数据是还没有提交的数据，那么另一个事务读到的就是脏数据\n第二是不可重复读：比如在一个事务中多次读同一数据。在这个数据还没影结束时，另一个事务也访问该数据，那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不一样，这就发生了在一个事务中两次读到的数据都是不一样的情况\n第三就是幻读：幻读与不可重复读，它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时，在随后的查询中，第一个书屋（T1）就会发现多了一些根本不存在的记录，就好像发生了幻觉一样。\nQ：怎么解决这些问题？mysql的默认隔离级别是？\nA:msql支持四种隔离级别，分别有：\n第一个是，未提交读(read uncommitted)它解决不了刚才提出的所有问题，一般项目中也不用这个，第二个是读已提交(read committed)他能解决脏读的问题，但是解决不赖哦可重复度和幻读。第三个是可重复读(repeatable read)他能解决脏读和不可重复读。但是解决不了幻读，这个也是msql的默认隔离级别。第四个是串行化(serializable)它可以解决刚才提出来的所有问题，但是由于让事务串行执行的，性能比较低，所有我们一般使用的是msql默认的隔离级别：可重复读\n15.undo log和read log区别 redo log日志记录的是数据页的物理变化，服务宕机可用来同步数据，而undo log不同，它主要记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，比如我们删除一条数据的时候，会会在undo log日志文件中新增一条delete语句，如果发生回滚就执行逆操作；\nredo log保证了事务的持久性，而undo log保证了事务的原子性和一致性\n","date":"2025-08-10T01:18:23+08:00","permalink":"https://hayden-spec.github.io/p/java%E5%85%AB%E8%82%A1/","title":"Java八股"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://hayden-spec.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://hayden-spec.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://hayden-spec.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://hayden-spec.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://hayden-spec.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://hayden-spec.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://hayden-spec.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://hayden-spec.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://hayden-spec.github.io/p/emoji-support/","title":"Emoji Support"},{"content":"用户管理 一.如何封装返回结果 Results工具类： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public final class Results { /** * 构造成功响应 */ public static Result\u0026lt;Void\u0026gt; success() { return new Result\u0026lt;Void\u0026gt;() .setCode(Result.SUCCESS_CODE); } /** * 构造带返回数据的成功响应 */ public static \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt; success(T data) { return new Result\u0026lt;T\u0026gt;() .setCode(Result.SUCCESS_CODE) .setData(data); } /** * 构建服务端失败响应 */ public static Result\u0026lt;Void\u0026gt; failure() { return new Result\u0026lt;Void\u0026gt;() .setCode(BaseErrorCode.SERVICE_ERROR.code()) .setMessage(BaseErrorCode.SERVICE_ERROR.message()); } /** * 通过 {@link AbstractException} 构建失败响应 */ public static Result\u0026lt;Void\u0026gt; failure(AbstractException abstractException) { String errorCode = Optional.ofNullable(abstractException.getErrorCode()) .orElse(BaseErrorCode.SERVICE_ERROR.code()); String errorMessage = Optional.ofNullable(abstractException.getErrorMessage()) .orElse(BaseErrorCode.SERVICE_ERROR.message()); return new Result\u0026lt;Void\u0026gt;() .setCode(errorCode) .setMessage(errorMessage); } /** * 通过 errorCode、errorMessage 构建失败响应 */ public static Result\u0026lt;Void\u0026gt; failure(String errorCode, String errorMessage) { return new Result\u0026lt;Void\u0026gt;() .setCode(errorCode) .setMessage(errorMessage); } } Result类： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Data @Accessors(chain = true) public class Result\u0026lt;T\u0026gt; implements Serializable { @Serial private static final long serialVersionUID = 5679018624309023727L; /** * 正确返回码 */ public static final String SUCCESS_CODE = \u0026#34;0\u0026#34;; /** * 返回码 */ private String code; /** * 返回消息 */ private String message; /** * 响应数据 */ private T data; /** * 请求ID */ private String requestId; public boolean isSuccess() { return SUCCESS_CODE.equals(code); } } 全局异常处理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 全局异常处理器 * */ @Component @Slf4j @RestControllerAdvice public class GlobalExceptionHandler { /** * 拦截参数验证异常 */ @SneakyThrows @ExceptionHandler(value = MethodArgumentNotValidException.class) public Result validExceptionHandler(HttpServletRequest request, MethodArgumentNotValidException ex) { BindingResult bindingResult = ex.getBindingResult(); FieldError firstFieldError = CollectionUtil.getFirst(bindingResult.getFieldErrors()); String exceptionStr = Optional.ofNullable(firstFieldError) .map(FieldError::getDefaultMessage) .orElse(StrUtil.EMPTY); log.error(\u0026#34;[{}] {} [ex] {}\u0026#34;, request.getMethod(), getUrl(request), exceptionStr); return Results.failure(BaseErrorCode.CLIENT_ERROR.code(), exceptionStr); } /** * 拦截应用内抛出的异常 */ @ExceptionHandler(value = {AbstractException.class}) public Result abstractException(HttpServletRequest request, AbstractException ex) { if (ex.getCause() != null) { log.error(\u0026#34;[{}] {} [ex] {}\u0026#34;, request.getMethod(), request.getRequestURL().toString(), ex.toString(), ex.getCause()); return Results.failure(ex); } log.error(\u0026#34;[{}] {} [ex] {}\u0026#34;, request.getMethod(), request.getRequestURL().toString(), ex.toString()); return Results.failure(ex); } /** * 拦截未捕获异常 */ @ExceptionHandler(value = Throwable.class) public Result defaultErrorHandler(HttpServletRequest request, Throwable throwable) { log.error(\u0026#34;[{}] {} \u0026#34;, request.getMethod(), getUrl(request), throwable); return Results.failure(); } private String getUrl(HttpServletRequest request) { if (StringUtils.isEmpty(request.getQueryString())) { return request.getRequestURL().toString(); } return request.getRequestURL().toString() + \u0026#34;?\u0026#34; + request.getQueryString(); } } ","date":"0001-01-01T00:00:00Z","permalink":"https://hayden-spec.github.io/p/","title":""}]